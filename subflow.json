{
    "id": "bd128c8517e37ccc",
    "type": "subflow",
    "name": "DataPlug History",
    "info": "# DataPlug History\r\n\r\nThis subflow retrieves historical time-series data from a partitioned SQLite database and allows for configurable aggregation.\r\n\r\n### Features\r\n\r\n-   **Handles Time-Based Partitions**: Automatically queries the correct monthly data tables.\r\n-   **Data Enrichment**: Attaches the correct measurement **unit**, **description**, and **category** from a `var` table.\r\n-   **Flexible Time Range**: Supports dynamic (via `msg.payload`) and static (via node properties) time ranges.\r\n-   **Configurable Aggregation**: Allows selecting the aggregation function (Average, Min, Max, Difference), time interval, raw data, or the last recorded value.\r\n-   **Advanced Category Filtering**: If a category is selected, it will filter the results to only include channels within that category.\r\n\r\n### Configuration\r\n\r\n-   **`Default time range`**: Sets the time period to query.\r\n-   **`Aggregation Function`**: Sets the SQL function for aggregation. \r\n-   **`Aggregation Interval`**: Sets the time window for grouping data. Select \"None\" for raw data or \"Last Value Only\" for the most recent point.\r\n-   **`Filter by Category`**: A dropdown to select a category to filter by.\r\n\r\n### Inputs\r\n\r\n-   `channels` (Array, Optional): An array of channel names.\r\n-   `from` (Number, Optional): Start timestamp in milliseconds.\r\n-   `to` (Number, Optional): End timestamp in milliseconds.\r\n\r\n### Outputs\r\n\r\n-   `msg.payload` (Object): A single object where each key is a channel name. Each channel object contains `min`, `max`, `unit`, `description`, `category`, `start_time`, `end_time`, and an array of `records`.",
    "category": "analysis",
    "in": [
        {
            "x": 60,
            "y": 280,
            "wires": [
                {
                    "id": "a19654bff08b7be1"
                }
            ]
        }
    ],
    "out": [
        {
            "x": 1520,
            "y": 280,
            "wires": [
                {
                    "id": "25cc6fd353269897",
                    "port": 0
                }
            ]
        }
    ],
    "env": [
        {
            "name": "channels",
            "type": "str",
            "value": "",
            "ui": {
                "icon": "font-awesome/fa-tags",
                "label": {
                    "fr": "Tags"
                },
                "type": "input",
                "opts": {
                    "types": [
                        "str"
                    ]
                }
            }
        },
        {
            "name": "timeRange",
            "type": "str",
            "value": "1d",
            "ui": {
                "label": {
                    "en-US": "Default time range"
                },
                "type": "select",
                "opts": {
                    "opts": [
                        {
                            "l": {
                                "en-US": "Use input message"
                            },
                            "v": "dynamic"
                        },
                        {
                            "l": {
                                "en-US": "Last 15 minutes"
                            },
                            "v": "15m"
                        },
                        {
                            "l": {
                                "en-US": "Last hour"
                            },
                            "v": "1h"
                        },
                        {
                            "l": {
                                "en-US": "Last 6 hours"
                            },
                            "v": "6h"
                        },
                        {
                            "l": {
                                "en-US": "Last 12 hours"
                            },
                            "v": "12h"
                        },
                        {
                            "l": {
                                "en-US": "Last 24 hours"
                            },
                            "v": "24h"
                        },
                        {
                            "l": {
                                "en-US": "Last 2 days"
                            },
                            "v": "2d"
                        },
                        {
                            "l": {
                                "en-US": "Last 7 days"
                            },
                            "v": "7d"
                        },
                        {
                            "l": {
                                "en-US": "Last 30 days"
                            },
                            "v": "30d"
                        }
                    ]
                }
            }
        },
        {
            "name": "aggFunc",
            "type": "str",
            "value": "AVG",
            "ui": {
                "label": {
                    "en-US": "Aggregation Function"
                },
                "type": "select",
                "opts": {
                    "opts": [
                        {
                            "l": {
                                "en-US": "Difference (for counters)"
                            },
                            "v": "DELTA"
                        },
                        {
                            "l": {
                                "en-US": "Average"
                            },
                            "v": "AVG"
                        },
                        {
                            "l": {
                                "en-US": "Minimum"
                            },
                            "v": "MIN"
                        },
                        {
                            "l": {
                                "en-US": "Maximum"
                            },
                            "v": "MAX"
                        }
                    ]
                }
            }
        },
        {
            "name": "aggInterval",
            "type": "str",
            "value": "%Y-%m-%d %H:%M",
            "ui": {
                "label": {
                    "en-US": "Aggregation Interval"
                },
                "type": "select",
                "opts": {
                    "opts": [
                        {
                            "l": {
                                "en-US": "Last Value Only"
                            },
                            "v": "last"
                        },
                        {
                            "l": {
                                "en-US": "None (raw data)"
                            },
                            "v": "none"
                        },
                        {
                            "l": {
                                "en-US": "Per Minute"
                            },
                            "v": "%Y-%m-%d %H:%M"
                        },
                        {
                            "l": {
                                "en-US": "Per Hour"
                            },
                            "v": "%Y-%m-%d %H"
                        },
                        {
                            "l": {
                                "en-US": "Per Day"
                            },
                            "v": "%Y-%m-%d"
                        }
                    ]
                }
            }
        },
        {
            "name": "category",
            "type": "str",
            "value": "none",
            "ui": {
                "label": {
                    "en-US": "Filter by Category"
                },
                "type": "select",
                "opts": {
                    "opts": [
                        {
                            "l": {
                                "en-US": "None"
                            },
                            "v": "none"
                        },
                        {
                            "l": {
                                "en-US": "Measure"
                            },
                            "v": "measure"
                        },
                        {
                            "l": {
                                "en-US": "State"
                            },
                            "v": "state"
                        },
                        {
                            "l": {
                                "en-US": "Counter"
                            },
                            "v": "counter"
                        },
                        {
                            "l": {
                                "en-US": "Alarm"
                            },
                            "v": "alarm"
                        }
                    ]
                }
            }
        }
    ],
    "meta": {
        "module": "node-red-contrib-hexa-ai-edge",
        "type": "dataplug-history",
        "version": "1.0.0",
        "author": "Julien TALBOURDET <contact@hexa-ai.fr>",
        "desc": "Retrieves and aggregates historical data from the SQLite DataPlug database.",
        "keywords": "dataplug, sqlite, min, max, average, history",
        "license": "Apache-2.0"
    },
    "color": "#FFCC66",
    "inputLabels": [
        "Params"
    ],
    "outputLabels": [
        "Results"
    ],
    "icon": "node-red/leveldb.svg",
    "flow": [
        {
            "id": "a19654bff08b7be1",
            "type": "function",
            "z": "bd128c8517e37ccc",
            "name": "1. Process Inputs",
            "func": "const timeRange = env.get('timeRange');\n\n// 1. Récupération sécurisée des 'channels'\n// Vérifie que msg.payload existe AVANT d'essayer de lire msg.payload.channels\nlet channels = (msg.payload && msg.payload.channels) || [];\n\n// 2. Récupération des 'channels' depuis la variable d'environnement\nconst newChannelsStr = env.get('channels');\n\n// 3. Traitement et ajout des nouveaux 'channels' s'ils existent\nif (newChannelsStr && typeof newChannelsStr === 'string') {\n    const newChannelsArr = newChannelsStr.split(',')\n        .map(channel => channel.trim())\n        .filter(channel => channel.length > 0);\n\n    const combinedChannels = new Set([...channels, ...newChannelsArr]);\n    channels = Array.from(combinedChannels);\n}\n\nlet from_ms, to_ms;\n\n// --- LIGNE CORRIGÉE ---\n// On ajoute une vérification pour s'assurer que msg.payload existe avant de lire .from et .to\nif (timeRange === 'dynamic' || (msg.payload && msg.payload.from && msg.payload.to)) {\n    // Si on est en mode dynamique ou si les temps sont fournis, on les utilise\n    // On met des valeurs par défaut au cas où msg.payload n'existerait pas en mode 'dynamic'\n    from_ms = msg.payload ? msg.payload.from : undefined;\n    to_ms = msg.payload ? msg.payload.to : undefined;\n}\n\n// Si après la première vérification on n'a toujours pas de dates valides, on passe au calcul par défaut\nif (!from_ms || !to_ms) {\n    to_ms = Date.now();\n    let duration_ms = 0;\n    switch (timeRange) {\n        case '15m': duration_ms = 15 * 60 * 1000; break;\n        case '1h': duration_ms = 60 * 60 * 1000; break;\n        case '6h': duration_ms = 6 * 60 * 60 * 1000; break;\n        case '12h': duration_ms = 12 * 60 * 60 * 1000; break;\n        case '24h': duration_ms = 24 * 60 * 60 * 1000; break;\n        case '2d': duration_ms = 2 * 24 * 60 * 60 * 1000; break;\n        case '7d': duration_ms = 7 * 24 * 60 * 60 * 1000; break;\n        case '30d': duration_ms = 30 * 24 * 60 * 60 * 1000; break;\n        default: duration_ms = 60 * 60 * 1000; // Sécurité : 1h par défaut si timeRange est invalide\n    }\n    from_ms = to_ms - duration_ms;\n}\n\n// Passe toute la configuration au nœud suivant\nmsg.config = {\n    from: from_ms,\n    to: to_ms,\n    channels: channels,\n    aggFunc: env.get('aggFunc') || 'AVG',\n    aggInterval: env.get('aggInterval') || '%Y-%m-%d %H:%M',\n    category: env.get('category') || 'none'\n};\n\nreturn msg;",
            "outputs": 1,
            "timeout": 0,
            "noerr": 0,
            "initialize": "",
            "finalize": "",
            "libs": [],
            "x": 230,
            "y": 280,
            "wires": [
                [
                    "1b3e6469af9eed5d"
                ]
            ]
        },
        {
            "id": "1b3e6469af9eed5d",
            "type": "function",
            "z": "bd128c8517e37ccc",
            "name": "2. Prepare Data Request",
            "func": "const config = msg.config;\n\nlet partitions = [];\nlet startDate = new Date(config.from);\nlet endDate = new Date(config.to);\nlet currentDate = new Date(Date.UTC(startDate.getUTCFullYear(), startDate.getUTCMonth(), 1));\n\nwhile (currentDate <= endDate) {\n    let year = currentDate.getUTCFullYear();\n    let month = (currentDate.getUTCMonth() + 1).toString().padStart(2, '0');\n    partitions.push(`hai_data_${year}${month}`);\n    currentDate.setUTCMonth(currentDate.getUTCMonth() + 1);\n}\n\nif (partitions.length === 0) { return null; }\n\nconst unionParts = partitions.map(p => `SELECT timestamp, channel_name, value_numeric FROM ${p}`);\nconst unionQuery = unionParts.join(' UNION ALL ');\n\n// Build the channel filter logic\nlet channelsFilter;\nconst hasChannels = config.channels && config.channels.length > 0;\nconst hasCategory = config.category !== 'none';\n\nif (hasChannels && hasCategory) {\n    const channelsList = config.channels.map(c => `'${c}'`).join(',');\n    channelsFilter = `sub.channel_name IN (SELECT channel_name FROM hai_vars WHERE category = '${config.category}' AND channel_name IN (${channelsList}))`;\n} else if (hasChannels) {\n    const channelsList = config.channels.map(c => `'${c}'`).join(',');\n    channelsFilter = `sub.channel_name IN (${channelsList})`;\n} else if (hasCategory) {\n    channelsFilter = `sub.channel_name IN (SELECT channel_name FROM hai_vars WHERE category = '${config.category}')`;\n} else {\n    node.warn(\"No channels or category specified. Stopping.\");\n    return null; // Stop flow if no channels or category are provided\n}\n\nlet finalQuery;\n\n// Check the aggregation mode\nif (config.aggInterval === 'none') {\n    // Mode: Raw Data\n    finalQuery = `\n    SELECT\n        sub.timestamp as ts,\n        sub.value_numeric as value,\n        sub.channel_name\n    FROM\n        (${unionQuery}) AS sub\n    WHERE\n        sub.timestamp BETWEEN ${config.from} AND ${config.to}\n        AND ${channelsFilter}\n    ORDER BY\n        ts ASC;`;\n} else if (config.aggInterval === 'last') {\n    // Mode: Last Value Only\n    finalQuery = `\n    SELECT\n        t1.timestamp as ts,\n        t1.value_numeric as value,\n        t1.channel_name\n    FROM\n        (${unionQuery}) AS t1\n    INNER JOIN (\n        SELECT\n            channel_name,\n            MAX(timestamp) AS max_ts\n        FROM\n            (${unionQuery}) AS sub\n        WHERE\n            sub.timestamp BETWEEN ${config.from} AND ${config.to}\n            AND ${channelsFilter}\n        GROUP BY\n            channel_name\n    ) AS t2 ON t1.channel_name = t2.channel_name AND t1.timestamp = t2.max_ts;`;\n} else {\n    // Mode: Aggregation (AVG, MIN, MAX, DELTA)\n    let aggExpression = config.aggFunc === 'DELTA' ? '(MAX(sub.value_numeric) - MIN(sub.value_numeric))' : `${config.aggFunc}(sub.value_numeric)`;\n    finalQuery = `\n    SELECT\n        MIN(sub.timestamp) as ts,\n        ${aggExpression} as value,\n        sub.channel_name\n    FROM\n        (${unionQuery}) AS sub\n    WHERE\n        sub.timestamp BETWEEN ${config.from} AND ${config.to}\n        AND ${channelsFilter}\n    GROUP BY\n        sub.channel_name,\n        strftime('${config.aggInterval}', sub.timestamp / 1000, 'unixepoch')\n    ORDER BY\n        ts ASC;`;\n}\n\nmsg.topic = finalQuery;\ndelete msg.params;\n\nreturn msg;",
            "outputs": 1,
            "timeout": 0,
            "noerr": 0,
            "initialize": "",
            "finalize": "",
            "libs": [],
            "x": 490,
            "y": 280,
            "wires": [
                [
                    "88e075c70b6b1c2a"
                ]
            ]
        },
        {
            "id": "88e075c70b6b1c2a",
            "type": "sqlite",
            "z": "bd128c8517e37ccc",
            "mydb": "eda2dae8c3b1ab0d",
            "sqlquery": "msg.topic",
            "sql": "",
            "name": "Get Data",
            "x": 700,
            "y": 280,
            "wires": [
                [
                    "cb69b18fe38def36"
                ]
            ]
        },
        {
            "id": "cb69b18fe38def36",
            "type": "function",
            "z": "bd128c8517e37ccc",
            "name": "3. Prepare Unit Request",
            "func": "const data = msg.payload;\n\nif (!data || data.length === 0) {\n    return null;\n}\n\n// Store the main data to retrieve it later\nflow.set(\"pending_data\", data);\n\nconst uniqueChannels = [...new Set(data.map(item => item.channel_name))];\nconst channelsList = uniqueChannels.map(c => `'${c}'`).join(',');\n\n// Updated query to also select 'description' and 'category'\nmsg.topic = `SELECT channel_name, unit, description, category FROM hai_vars WHERE channel_name IN (${channelsList})`;\ndelete msg.params;\n\nreturn msg;",
            "outputs": 1,
            "timeout": 0,
            "noerr": 0,
            "initialize": "",
            "finalize": "",
            "libs": [],
            "x": 940,
            "y": 280,
            "wires": [
                [
                    "95c08bdb819e285d"
                ]
            ]
        },
        {
            "id": "95c08bdb819e285d",
            "type": "sqlite",
            "z": "bd128c8517e37ccc",
            "mydb": "eda2dae8c3b1ab0d",
            "sqlquery": "msg.topic",
            "sql": "",
            "name": "Get Units",
            "x": 1140,
            "y": 280,
            "wires": [
                [
                    "25cc6fd353269897"
                ]
            ]
        },
        {
            "id": "25cc6fd353269897",
            "type": "function",
            "z": "bd128c8517e37ccc",
            "name": "4. Combine Results",
            "func": "// Helper function to format dates as dd/mm/yyyy HH:MM:SS UTC\nfunction formatUTCDate(timestamp) {\n    const date = new Date(timestamp);\n    const day = date.getUTCDate().toString().padStart(2, '0');\n    const month = (date.getUTCMonth() + 1).toString().padStart(2, '0');\n    const year = date.getUTCFullYear();\n    const hours = date.getUTCHours().toString().padStart(2, '0');\n    const minutes = date.getUTCMinutes().toString().padStart(2, '0');\n    const seconds = date.getUTCSeconds().toString().padStart(2, '0');\n    return `${day}/${month}/${year} ${hours}:${minutes}:${seconds} UTC`;\n}\n\nconst varData = msg.payload;\nconst originalData = flow.get(\"pending_data\");\n\nif (!originalData) {\n    return null;\n}\n\nconst results = {};\n\n// Create a lookup map for units, descriptions, and categories\nconst varMap = {};\nif (varData && varData.length > 0) {\n    for (const item of varData) {\n        varMap[item.channel_name] = {\n            unit: item.unit,\n            description: item.description,\n            category: item.category\n        };\n    }\n}\n\n// Process the main data to build the series object\nfor (const row of originalData) {\n    const channel = row.channel_name;\n\n    // --- DÉBUT MODIFICATION 1 : Initialisation de avg, sum et count ---\n    if (!results[channel]) {\n        results[channel] = {\n            min: row.value,\n            max: row.value,\n            avg: 0, // Ajout de la propriété 'avg'\n            sum: 0, // Propriété temporaire pour le calcul\n            count: 0, // Propriété temporaire pour le calcul\n            unit: varMap[channel] ? varMap[channel].unit : null,\n            description: varMap[channel] ? varMap[channel].description : null,\n            category: varMap[channel] ? varMap[channel].category : null,\n            records: []\n        };\n    }\n    // --- FIN MODIFICATION 1 ---\n\n    results[channel].records.push({\n        ts: row.ts,\n        value: row.value\n    });\n    \n    // --- DÉBUT MODIFICATION 2 : Mise à jour de sum et count ---\n    if (typeof row.value === 'number') {\n        results[channel].sum += row.value;\n        results[channel].count++;\n    }\n    // --- FIN MODIFICATION 2 ---\n\n    if (row.value < results[channel].min) {\n        results[channel].min = row.value;\n    }\n    if (row.value > results[channel].max) {\n        results[channel].max = row.value;\n    }\n}\n\n// --- DÉBUT MODIFICATION 3 : Calcul final de la moyenne ---\n// Boucle finale pour calculer 'avg' et nettoyer les propriétés temporaires\nfor (const channel in results) {\n    if (results[channel].count > 0) {\n        results[channel].avg = results[channel].sum / results[channel].count;\n    }\n    // Suppression des propriétés de calcul inutiles dans la sortie\n    delete results[channel].sum;\n    delete results[channel].count;\n\n    // Ajout des dates de début/fin (code existant)\n    if (results[channel].records.length > 0) {\n        const firstRecord = results[channel].records[0].ts;\n        const lastRecord = results[channel].records[results[channel].records.length - 1].ts;\n        \n        results[channel].start_time = formatUTCDate(firstRecord);\n        results[channel].end_time = formatUTCDate(lastRecord);\n    }\n}\n// --- FIN MODIFICATION 3 ---\n\nmsg.payload = results;\nreturn msg;",
            "outputs": 1,
            "timeout": 0,
            "noerr": 0,
            "initialize": "",
            "finalize": "",
            "libs": [],
            "x": 1330,
            "y": 280,
            "wires": [
                []
            ]
        },
        {
            "id": "eda2dae8c3b1ab0d",
            "type": "sqlitedb",
            "db": "/database/data_storage.db",
            "mode": "RO"
        }
    ]
}